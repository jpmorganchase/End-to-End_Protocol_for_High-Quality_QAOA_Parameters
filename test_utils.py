import numpy as np
from functools import partial
from utils import (
    get_problem,
    precompute_energies_parallel,
    get_adjusted_state,
    get_problem_H,
    scale_map,
    generata_dicke_state,
    get_trottered_ring_xy_mixer,
    generate_dicke_state_fast
)
from circuit_utils import (
    get_configuration_cost_slow,
    get_configuration_cost,
    get_configuration_cost_kw,
    apply_mixer_Txy,
    apply_mixer_Txy_yue,
    get_qaoa_circuit,
    measure_circuit,
    get_mixer_Txy
)
from optimizer import circuit_measurement_function


def test_costs():
    N = 25
    K = 5
    q = 0.5
    seed = None
    scale = 1

    po_problem = get_problem(N=N, K=K, q=q, seed=seed, pre=scale)

    config = np.random.choice([0, 1], size=N)
    assert np.isclose(
        get_configuration_cost_slow(po_problem, config),
        get_configuration_cost(po_problem, config),
    )


def test_precompute():
    N = 6
    K = 5
    q = 0.5
    seed = None
    scale = 1
    po_problem = get_problem(N=N, K=K, q=q, seed=seed, pre=scale)

    po_obj = partial(get_configuration_cost_kw, po_problem=po_problem)

    precomputed_energies = get_adjusted_state(
        precompute_energies_parallel(po_obj, N, 2)
    )

    H_diag = np.diag(get_problem_H(po_problem))
    np.allclose(precomputed_energies, H_diag)


def test_qaoa_objective():
    from qiskit.quantum_info import Statevector
    import sys

    for N in [6,5]:
        K = 3
        q = 0.5
        seed = 2053
        scale = 1
        po_problem = get_problem(N=N, K=K, q=q, seed=seed, pre=scale)

        po_obj = partial(get_configuration_cost_kw, po_problem=po_problem)
        precomputed_energies = get_adjusted_state(
            precompute_energies_parallel(po_obj, N, 2)
        )

        p = 1
        for T in [1, 2]:
            print(f"N={N}, T={T}")
            gammas = np.random.rand(p)
            betas = np.random.rand(p)

            ##################################################
            # option 1: Zichang's implementation
            ##################################################
            qaoa_circuit = get_qaoa_circuit(
                po_problem=po_problem,
                gammas=gammas,
                betas=betas,
                depth=p,
                ini="dicke",  #'dicke' or 'ring_gs': note that ring_gs is not generated by gates
                mixer="t-xy",  # ring mixer
                T=T,
                ini_state=None,  # if we manually create a state as init
                save_state=True,
                minus=False,  # minus for ring mixer
            )
            sv1 = measure_circuit(qaoa_circuit)

            obj = circuit_measurement_function(
                po_problem=po_problem,
                p=p,
                ini="dicke",
                mixer="t-xy",
                T=T,
                ini_state=None,
                save_state=True,
                n_trials=1024,  # number of shots if save_state is False
                minus=False,
            )
            ini_x = np.concatenate((gammas, betas), axis=0)
            f1 = obj(ini_x)

            ##################################################
            # option 2: FURXY (Python)
            ##################################################

            from fur import QAOAFURXYRingSimulator

            sim = QAOAFURXYRingSimulator(N, precomputed_energies)
            sv4 = sim.simulate_qaoa(
                2 * gammas, 4 * betas, sv0=generata_dicke_state(N, K), n_trotters=T
            )
            f4 = (np.abs(sv4)**2).dot(precomputed_energies)
            
            if 'QAOAKit' in sys.modules:
                from QAOAKit.utils import obj_from_statevector
                f4_qaoakit = obj_from_statevector(
                    sv4, None, precomputed_energies=precomputed_energies
                )
                assert np.isclose(f1, f4_qaoakit)

            assert np.isclose(f1, f4)
            assert Statevector(sv1).equiv(sv4)

            ##################################################
            # option 3: FURXY (C)
            ##################################################

            from fur import QAOAFURXYRingSimulatorC

            sim = QAOAFURXYRingSimulatorC(N, precomputed_energies)
            sv5 = sim.simulate_qaoa(
                2 * gammas, 4 * betas, sv0=generata_dicke_state(N, K), n_trotters=T
            )
            f5 = sv5.get_norm_squared().dot(precomputed_energies)

            assert np.isclose(f1, f5)
            assert Statevector(sv1).equiv(sv5.get_complex())

def test_trotter_ring_unitary():
    N=6
    t=1
    beta=1
    from qiskit import QuantumRegister, QuantumCircuit
    q = QuantumRegister(N)
    circuit = QuantumCircuit(q)
    circuit = get_mixer_Txy(
                    circuit, beta/2, minus=False, T=t #minus should be false
                )
    from qiskit.quantum_info import Operator
    op = Operator(circuit)
    circuit_unitary = op.data
    
    U_ring = get_trottered_ring_xy_mixer(N=N, ring=True, T=t, beta=beta/t)
    assert np.allclose(U_ring,circuit_unitary)
    

def test_generate_dicke_state():
    for N in [10,11]:
        for K in [4,5]:
            s1 = generata_dicke_state(N,K)
            s2 = generate_dicke_state_fast(N,K)
            assert np.allclose(s1,s2)